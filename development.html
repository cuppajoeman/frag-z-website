<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>progress</title>
    <link rel="stylesheet" href="index.css">
    <style>
        .todo {
            color: red;
        }
    </style>
</head>
<body>

<div class="top_bar">
    <a href="index.html">
        <img src="assets/text/frag-z-text.png" alt="" style="height: 70px;">
    </a>
    <ul>
        <li><a href="https://discord.gg/FDkzF3C7C6"><h2>discord</h2></a></li>
        <li><a href="store.html"><h2>store</h2></a></li>
        <li><a href="download.html"><h2>download</h2></a></li>
        <li><a href="development.html"><h2>development</h2></a></li>
        <li><a href="info.html"><h2>info</h2></a></li>
    </ul>
</div>
<div class="wrapper">
    <h1>
        <div id="fire-text">
            development
        </div>
    </h1>

    <h2>code base overview</h2>
    <p>
        first a server is started, then a client connects to it.
    </p>
    <h3>client</h3>
    <ul>
        <li>
            when the client is started a UI appears where you can specify the server and the port, after the player
            presses
            connect, a connection is made to the server, and the game is loaded up
        </li>
        <li>
            in the main client script we override <code>_process</code> which is a built-in godot method which runs
            evertime a frame is drawn
            <span class="todo">(todo: using the process function is bad)</span>
            <ul>
                <li>
                    we first check if we're connected to the server <span class="todo">(todo: process shouldn't be called if we're not connected?)</span>
                </li>
                <li>
                    if we're not typing we call <code>input_state.update_state()</code>, here <code>input_state</code>
                    is a class which handles the input of the client and <code>update_state</code> is a method which
                    updates the keyboard/mouse inputs
                </li>
                <li>
                    next we send the keyboard/mouse state to the server through an <code>rpc</code> call, calling
                    <code>update_player_inputs_server</code> <span class="todo">(todo: Naming)</span>
                </li>
                <ul>
                    <li>
                        note that in godot, an rpc function must exist in the client and server at the same node, so
                        that's
                        why the client code has an instance of <code>update_player_inputs_server</code> with an empty
                        implementation
                    </li>
                </ul>
                <li>
                    now start reading how the server works, come back here when you're done reading it.
                </li>
            </ul>
        </li>
    </ul>

    <h3>server</h3>
    <ul>
        <li>
            when the server starts a check is made to see if it's running headless (no graphics) or not, for the
            headless
            version the server operates in the same fashion, just without a visual representation, so we'll just discuss
            the
            visual server mode for now.
        </li>
        <li>
            a ui appears where you can pick max players and a port, when you click start the server is initialized
            , a <code>Referee</code> is initialized and a most points win match is started <span class="todo">(todo: need to be able to choose
            game mode from the ui)</span>
        </li>
        <li>
            the way we're going to think of the server is like any other sports game, basketball/baseball/soccer/etc...,
            so we'll have players, each have the following:
            <ul>
                <li>players, who perform the following actions, informed by the current game mode (ex: shoot outs vs
                    normal play)
                </li>
                <ul>
                    <li>moving</li>
                    <li>kicking/throwing a ball</li>
                    <li>interacting with other players</li>
                </ul>
                <li>rulebook, for a certain game</li>
                <ul>
                    <li>contains all rules associated with that game (ex. <a
                            href="https://digitalhub.fifa.com/m/3f3e15cc1ab8977b/original/datdz0pms85gbnqy4j3k-pdf.pdf">fifa
                        soccer rules</a>)
                    </li>
                </ul>
                <li>referee, someone who keeps track of the game and allocates points to different teams/players (goals,
                    red cards, fouls etc...)
                </li>
                <ul>
                    <li>decides whether points are valid</li>
                    <li>can give points, red cards, fouls to players and is the authority</li>
                </ul>
            </ul>
        </li>
        <li>
            so our game server will have players
            <ul>
                <li>each controlled by one client</li>
                <li>in charge of movement and shooting</li>
            </ul>
        </li>
        <li>rulebooks, for each game mode in the game <span class="todo">(todo: implement this)</span></li>
        <ul>
            <li>whether or not the game is timed</li>
            <li>whether or not the game won by reaching a certain number of points</li>
        </ul>
        <li>
            a single referee (the authority over the players)
            <ul>
                <li>allocates points to players based on the current game mode's rulebook</li>
                <li>decides if the game is over based on the current game mode's rulebook</li>
                <li>other events such as map voting etc...</li>
            </ul>
        </li>
        <li>
            once the server is started we override the <code>_process</code> method like in the client <span
                class="todo">(todo: don't use process)</span> and inside of this method:
        </li>
        <ul>
            <li>we send the player position and rotation of each player to each client</li>
            <li>we send the state of the match to each client</li>
            <li>update the server hud</li>
            <li>send messages to each client</li>
        </ul>
    </ul>


    <h2>dev log</h2>

    <details>
        <summary>january 2022 development</summary>
        <p>
            this month started off with the very first game test, with Nel, coli, Jacques, Teeare and me, the game test
            went well and fun was had.
        </p>
        <img src="frag-z-game-test-%231.png" alt="" style="width: 50%;">
        <h2>feedback</h2>
        <ul>
            <li>hud scales up with resolution</li>
            <li>tab activated scoreboard</li>
            <li>deathmatch gamemode</li>
            <ul>
                <li>create deathmatch map (thinking sewer level)</li>
            </ul>
            <li>view direction of enemy players</li>
            <ul>
                <li>potentially add weapon model</li>
            </ul>
            <li>movement has some quirks</li>
            <ul>
                <li>movement reverses with A/D only movement</li>
                <li>circle hop with W only movement</li>
            </ul>
            <li>AMD support</li>
            <li>show movement stats on client</li>
            <ul>
                <li>show the velocity vector</li>
            </ul>
        </ul>
        <h2>plan</h2>
        <ul>
            <li>death match</li>
            <p>
                On 2023-01-05 I decided that <code>Rulebook</code> isn't the right name for the class, it should just be
                <code>Match</code> since a <code>Rulebook</code> shouldn't have methods, as it's only a book.
            </p>
            <p>
                Notice that death match isn't actually that different from most points win, for example health can be
                considered points, and that whenever your points go below 1, then you will respawn elsewhere on the map
                with 100 points again.
            </p>
            <ul>
                <li>
                    implement abstract <code>Rulebook</code>, then create <code>Rulebooks</code> for deathmatch and
                    most points win
                </li>
                <ul>
                    <li>
                        in the deathmatch match, it will also contain the method <code>weapon_transaction(source_player, target_players)</code>
                    </li>
                    <ul>
                        <li><s>create abstract match class</s>(2023-01-04)</li>
                        <li><s>create subclasses for actual match types</s>(2023-01-04)</li>
                        <li><s>add transaction method</s>(2023-01-04)</li>
                    </ul>
                    <li>
                        for now deathmatch will be timed
                    </li>
                </ul>
                <li>
                    <s>remove the logic inside of the railgun, and simply use <code>GlobalPlayerEvents</code></s>(2023-01-06)
                </li>
                <li>move the fire check inside of the player</li>
                <ul>
                    give the weapon a
                </ul>
            </ul>
            <li>new map</li>
            <p>
                in order to support the new game mode, we are going to build a new map oriented more towards death match
            </p>
            <ul>
                <li>more long flat areas to fight on, not as vertical as previous map</li>
                <li>more wedges that aren't steep</li>
            </ul>
            <li>projectile launcher</li>
            <ul>
                <li>create projectile launcher class</li>
                <li>implement the physics movement function</li>
                <li>implement check to see if it's collided</li>
                <li>implement explosion</li>
                <ul>
                    <li>create a sphere at the explosion point, with <code>explosion_radius</code></li>
                    <li>
                        for each colliding thing, if it's a player, then draw a ray from the blast origin to the
                        center of the player, if it reaches that player, then we can apply a force to the player, also
                        perform a transaction (no points lost if you shoot yourself, only to other players)
                    </li>
                </ul>
            </ul>
            <li>shotgun & lightning gun</li>
            <ul>
                <li>
                    generalize the hitscan weapon, this generalized version has a method called <code>get_spray_pattern</code>
                    which will returns a list of hitscan rays. It will also have a method called <code>fire</code> which
                    iterates through the spray pattern and uses the referee to conduct a hitscan transaction.
                </li>
                <li>
                    in order to play different sounds for the different weapons, more information needs to be added in
                    players events pertaining to firing, we also have to specify which weapon is being fired.
                </li>
            </ul>
            <li>movement</li>
            <ul>
                <li>quake style movement</li>
                <li>turn of auto jump, implement queue jump</li>
                <ul>
                    <li>we don't jump if we never received a false for jump pressed before the next time we hit the ground</li>
                </ul>
            </ul>
        </ul>
    </details>

    <details>
        <summary>december 2022 development</summary>
        <p>
            first we will develop a thin slice through the whole game, that way we will have a minimal working game that
            can
            be played.
            this way we can get user feedback as fast as possible instead of building the whole game and then having to
            undo
            previous work.
        </p>
        <p>
            the thin slice will be a version of the game where you can connect to a server online through a UI, be able
            to
            ready
            your players and then start the game, the game will be mpw with a single weapon (rail gun), rail gun beams
            will
            be
            rendered on the client side and a scoreboard will be shown. After 10 minutes the game ends and you are
            returned
            to the
            ready up state.
        </p>
        <ul>
            <li><h2>slice</h2></li>
            <ul>
                <li>client side</li>
                <ul>
                    <li><s>send over keypresses, mouse deltas to server</s>(2022-12-18)</li>
                    <li><s>terminal with sensitivity command</s>(2022-12-18)</li>
                    <li><s>crosshair</s>(2022-12-27)</li>
                </ul>
                <li>server side</li>
                <ul>
                    <li><s>process keypresses and mouse deltas, send back rotation and position of player</s>(2022-12-20)
                    </li>
                    <li><s>create a Match class</s></li>
                    <ul>
                        <li><s>contains the current state of the match preparation, live and complete</s>(2022-12-26)
                        </li>
                        <ul>
                            <li><s>the complete state shows the scoreboard for everyone for at least 30 seconds.</s>(2022-12-28)
                            </li>
                        </ul>
                        <li><s>contains a Referee class which monitors shots fired and allocates points to respective
                            players</s></li>
                        <ul>
                            <li><s>it is aware of the current game type</s>(2022-12-26)</li>
                            <li><s>each step of the game, we can ask the referee if the game is over.</s>(2022-12-25)
                            </li>
                        </ul>
                        <li><s>scoring information passed along with high frequency info</s>(2022-12-26)</li>
                        <li><s>if the Referee says the game is over, we move to the complete state</s>(2022-12-28)</li>
                    </ul>
                    <li><s>chat messaging service</s>(2022-12-28)</li>
                </ul>
            </ul>
            <li><h2>development</h2></li>
            <ul>
                <li>after the slice is developed we will work on features in the order most requested by the users it
                    will
                    probably be in this order
                </li>
                <ul>
                    <li>sound/visual representation</li>
                    <li>new maps</li>
                    <li>add the other weapons</li>
                    <li>team based gameplay</li>
                </ul>
            </ul>
            <li><h2>performance</h2></li>
            <ul>
                <li>netcode</li>
                <ul>
                    <li>don't send info if there is no delta</li>
                </ul>
            </ul>
            <li><h2>infrastructure</h2></li>
            <ul>
                <li><s>make discord server</s>(2022-12-22)</li>
                <li><s>make website</s>(2022-12-25)</li>
                <li>headless server</li>
                <ul>
                    <li><s>aquire remote linux machine</s>(2022-12-29)</li>
                    <li><s>figure out how to compile game for headless</s>(2022-12-29)</li>
                </ul>
                <li>create download section on website</li>
                <li>auto updater (long term)</li>
            </ul>
            <h2>review</h2>
            <p>
                this month was really good, I managed to get the game into a playable state in about a week. i built a
                map
                a system to run sound on the client, weapons, a referee system, messaging/commands and smoothed out
                movement.
            </p>
        </ul>
    </details>


</div>
</body>
</html>